// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

interface ICredentialRegistry {
    enum Status { NONE, VALID, REVOKED }
    function getCredentialInfo(uint256 tokenId) external view returns (
        string memory issuerID,
        bytes32 metaHash,
        uint256 expiry,
        Status status
    );
    function validator() external view returns (address);
}

contract CredentialSBT is ERC721, Ownable {
    ICredentialRegistry public registry;

    // track minted SBT per registry tokenId
    mapping(uint256 => bool) public minted;

    event MintedSBT(address indexed to, uint256 indexed tokenId, bytes32 metaHash, uint256 expiry);

    constructor(address registryAddress, string memory name_, string memory symbol_) ERC721(name_, symbol_) {
        require(registryAddress != address(0), "zero registry");
        registry = ICredentialRegistry(registryAddress);
    }

    /// @notice only validator from registry may mint SBT
    modifier onlyValidator() {
        require(msg.sender == registry.validator(), "Not validator");
        _;
    }

    /**
     * mintSBT
     * - called by Validator
     * - tokenId = registry tokenId (auto-generated by registry)
     * - candidateWallet = recipient
     * - metaHash & expiry must match registry stored values
     */
    function mintSBT(
        uint256 tokenId,
        address candidateWallet,
        bytes32 metaHash,
        uint256 expiry
    ) external onlyValidator {
        require(candidateWallet != address(0), "zero candidate");
        // 1) check registry has credential and return details
        ( , bytes32 onchainMetaHash, uint256 onchainExpiry, ICredentialRegistry.Status status) = registry.getCredentialInfo(tokenId);

        require(status == ICredentialRegistry.Status.VALID, "No attested credential");
        // 2) metadata match
        require(onchainMetaHash == metaHash && onchainExpiry == expiry, "Metadata mismatch");
        // 3) not minted before
        require(!minted[tokenId], "SBT already minted");

        // mark minted
        minted[tokenId] = true;

        // mint ERC721 token with tokenId same as registry tokenId
        _safeMint(candidateWallet, tokenId);

        emit MintedSBT(candidateWallet, tokenId, metaHash, expiry);
    }

    /** Soulbound: disallow transfers and approvals **/

    // NOTE: OZ 4.9+ uses _beforeTokenTransfer(address,address,uint256,uint256)
    // we must match that signature and call super with 4 args.
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 firstTokenId,
        uint256 batchSize
    ) internal virtual override (ERC721) {
        // allow minting (from == 0) and burning (to == 0) only
        // disallow any transfer between addresses
        // batchSize support: when batchSize > 1, this is part of a batch mint; still block transfers.
        require(from == address(0) || to == address(0), "Soulbound: non-transferable");
        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);
    }

    // disallow ERC721 approvals / transfers (tidak perlu nama param karena tidak dipakai)
    function approve(address, uint256) public virtual override {
        revert("Soulbound: non-transferable");
    }

    function setApprovalForAll(address, bool) public virtual override {
        revert("Soulbound: non-transferable");
    }

    function transferFrom(address, address, uint256) public virtual override {
        revert("Soulbound: non-transferable");
    }

    function safeTransferFrom(address, address, uint256) public virtual override {
        revert("Soulbound: non-transferable");
    }

    function safeTransferFrom(address, address, uint256, bytes memory) public virtual override {
        revert("Soulbound: non-transferable");
    }

    /// helper: admin dapat update registry address kalau perlu
    function setRegistry(address newRegistry) external onlyOwner {
        require(newRegistry != address(0), "zero");
        registry = ICredentialRegistry(newRegistry);
    }
}
